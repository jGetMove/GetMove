#include <iostream>
#include <stdio.h>
#include <vector>
#include <string>
#include <cstring>
#include <set>
#include <map>
#include <list>
#include <sstream>
#include <fstream>
#include <cstdlib>
#include <cctype>
#include <algorithm>
#include <stdlib.h>     /* srand, rand */
#include <time.h>       /* time */
#include <stdexcept>

using namespace std;


string filename;
string data;
string outputfile;
vector<vector<int> > Itemsets;
std::string delim = "\t  ";
string ligne;
std::string token;


namespace patch
{
    template < typename T > std::string to_string( const T& n )
    {
        std::ostringstream stm ;
        stm << n ;
        return stm.str() ;
    }
}

bool mySortFunction(const vector<int>& inner1, const vector<int>& inner2) {
    return inner1.size() < inner2.size();
}


void parse (int argc, char **argv){
    if (argc != 3){
        cout << "usage: " << argv[0] << " filename data" << endl ;
        cout << "example: "<< argv[0] << "resulttrajectory initialdata.dat" << endl;
        cout << "resultrajectory is the file generated by lcm" << endl;
        cout << "initialdata.dat is the file in output of the lcm algorithm. Be careful the initialdatatimeindex.dat must be in the same directory" << endl;
        exit(0);
    }
        filename=argv[1];
        data=argv[2];
}

std::vector<std::string> split(const std::string& str, const std::string& delim){
    std::vector<std::string> result;
    if (str.empty())
        throw std::runtime_error("Can not tokenize an empty string!");
    std::string::const_iterator begin, str_it;
    begin = str_it = str.begin();
    do {
        while (delim.find(*str_it) == std::string::npos && str_it != str.end())
            str_it++; // find the position of the first delimiter in str
        std::string token = std::string(begin, str_it); // grab the token
        if (!token.empty()) // empty token only when str starts with a delimiter
            result.push_back(token); // push the token into a vector<string>
        while (delim.find(*str_it) != std::string::npos && str_it != str.end())
            str_it++; // ignore the additional consecutive delimiters
        begin = str_it; // process the remaining tokens
    } while (str_it != str.end());
    return result;
}

// De but de mise en place de la procedure de traitement des patterns
void ProcessPatterns(ifstream &filePathes, vector <int> &objects, vector <int> &times, map<int, vector<int> > &TheObjects, map<int, vector<int> > &TheTimes, int &nbpattern){
        // Find objects of the pattern
        string res;
        int currentcluster;

        getline(filePathes, ligne);
        std::vector<std::string> tokens = split(ligne, delim);
        bool first = true;
        for (std::vector<std::string>::const_iterator it = tokens.begin();it != tokens.end(); it++){
            res=*it;
            if (first) {
                // find the term Object
                first=false;
            }
            else {
                currentcluster=atoi(res.c_str());
                TheObjects[nbpattern].push_back(currentcluster);
                objects.push_back(currentcluster);
            }
        }
        // Find times of pattern
        getline(filePathes, ligne);
        tokens = split(ligne, delim);
        first = true;
        for (std::vector<std::string>::const_iterator it = tokens.begin();it != tokens.end(); it++){
            res=*it;
            if (first) {
                // find the term Object
                first=false;
            }
            else {
                currentcluster=atoi(res.c_str());
                TheTimes[nbpattern].push_back(currentcluster);
                times.push_back(currentcluster);
            }
        }

        nbpattern++;

}


void printPatterns(map<int, vector<int> > &TheObjects,
                  map<int, vector<int> > &TheTimes,
                  int nbpattern){
    map<int, vector<int> >::iterator ite;
    for (int i=0; i < (int)nbpattern; i++){
        cout << i << " : ";
        cout << endl;
        cout << " - " << "objects: " << " ";
        ite=TheObjects.find(i);

        vector<int> intvec = ite->second;
        for(int j = 0; j < (int)intvec.size(); j++)
        {
            cout << intvec[j] << ", ";
        }
        cout << endl;
        ite=TheTimes.find(i);
        cout << "Times: " << endl;
        intvec = ite->second;
        for(int j = 0; j < (int)intvec.size(); j++)
        {
            cout << intvec[j] << ", ";
        }
        cout << endl;
    }

}

void generateJsonPatterns(ofstream &fichier,
                          map<int, vector<int> > &TheObjects,
                          map<int, vector<int> > &TheTimes,
                          int nbpattern) {
  vector <int> source;
  vector <int> destination;
  map<int, vector<int> >::iterator ite;
    map<int, vector<int> >::iterator ite2;
  for (int i=0; i < (int)nbpattern; i++){
    source.clear();
    destination.clear();
    ite=TheTimes.find(i);

    vector<int> intvec = ite->second;
    for(int j = 0; j < (int)intvec.size()-1; j++)
      {
	source.push_back(intvec[j]);
	destination.push_back(intvec[j+1]);
      }
    for (size_t u=0; u < destination.size(); u++){
      cout << "\t{\"pattern\":\"" << i << "\",";
      fichier << "\t{\"pattern\":\"" << i << "\",";
      cout << "\"source\":"<< source[u] << "\",\"target\":\"" << destination[u] << "\",";
      fichier << "\"source\":"<< source[u] << "\",\"target\":\"" << destination[u] << "\",";
        ite2=TheObjects.find(i);
        vector<int> intvec2 = ite2->second;
        cout << "\"value=\"" << intvec2.size() << "\",\"label\":\"" ;
        fichier << "\"value=\"" << intvec2.size() << "\",\"label\":\"" ;
        for(int j = 0; j < (int)intvec2.size(); j++)
        {
            if (j < (int)intvec2.size()-1 ){
                cout << intvec2[j] << ",";
                fichier << intvec2[j] << ",";
            }
             else {
                cout << intvec2[j] << "\"}" ;
                fichier << intvec2[j] << "\"}" ;
            }
        }
        if (i < nbpattern-1 || u < destination.size() -1){
            cout << "," << endl;
            fichier << "," << endl;
        }
        else {
            cout << endl;
            fichier << endl;
        }
    }
  }
}

int main (int argc, char **argv){


    parse (argc, argv);


    vector<string> tab;




    string itemset="itemset:";

    std::string cluster;
    vector <int> items;
    vector <string> removeitemsets;
    vector <int> nodes;


    // init nodes
    string name = data;
    string timeindex;
    std::size_t pos = name.find(".");
    std::string beginpos =name.substr (0,pos);
    std::string endpos = name.substr (pos,name.length());
    timeindex=beginpos + "timeindex" + endpos;

    pos = filename.find(".");
    beginpos =filename.substr (0,pos);
    outputfile=beginpos+".json";
    cout << "\t\t\tGenerating a Json file" << endl;
    cout << "Imput files:" << endl;
    cout << "\tOriginal data: " << data << endl;
    cout << "\tAssociated time index file: " << timeindex << endl;
    cout << "\tGenerated from the LCM output file: " << filename << endl;
    cout << "\tOutput file: " << outputfile << endl;

    ifstream fileTimes(timeindex.c_str(), ios::in);


    if(!fileTimes)  {
        cerr << "Unable to open" << timeindex << endl;
        exit(-1);
    }

    // get clusters by time
    vector<vector <int> > clustersbytime;
    vector <int> clusters;


    int previoustime=-1;
    int currenttime;
    int currentcluster;
    bool first;
    string res;
    int Thecurrenttime;
    while(getline(fileTimes, ligne))
    {
        if (previoustime==-1){
            // First line analysis
            std::vector<std::string> tokens = split(ligne, delim);
            first = true;
            for (std::vector<std::string>::const_iterator it = tokens.begin();it != tokens.end(); it++){
                //std::cout << *it << " ";
                res=*it;
                if (first) {currenttime = atoi(res.c_str()); first=false;}
                else {currentcluster=atoi(res.c_str());break;}
            }
            clusters.push_back(currentcluster);
            Thecurrenttime=currenttime;

            // Second line analysis
            getline(fileTimes, ligne);

            tokens = split(ligne, delim);
            first = true;
            for (std::vector<std::string>::const_iterator it = tokens.begin();it != tokens.end(); it++){
                //std::cout << *it << " ";
                res=*it;
                if (first) {currenttime = atoi(res.c_str()); first=false;}
                else {currentcluster=atoi(res.c_str());break;}
            }

            if (Thecurrenttime!=currenttime){
                clustersbytime.push_back(clusters);
                clusters.clear();
                clusters.push_back(currentcluster);
            }
            else {

                clusters.push_back(currentcluster);
            }
            previoustime=currenttime;
        }
        else {
        std::vector<std::string> tokens = split(ligne, delim);
        first = true;
        for (std::vector<std::string>::const_iterator it = tokens.begin();it != tokens.end(); it++){
            res=*it;
            if (first) {currenttime = atoi(res.c_str()); first=false;}
            else {currentcluster=atoi(res.c_str());break;}
        }

        if (currenttime != previoustime ){
            clustersbytime.push_back(clusters);
            clusters.clear();
            clusters.push_back(currentcluster);

        }
       else {clusters.push_back(currentcluster);
           }
        previoustime=currenttime;
        }
    }
    clustersbytime.push_back(clusters);
    fileTimes.close();


    // Times per cluster
    ifstream fileClusters(timeindex.c_str(), ios::in);


    if(!fileClusters)  {
        cerr << "Unable to open" << timeindex << endl;
        exit(-1);
    }

    vector<vector <int> > timebyclusters;
    vector <int> times;
    int nbtimes=0;
    while(getline(fileClusters, ligne))
    {
        std::vector<std::string> tokens = split(ligne, delim);
        first = true;
        for (std::vector<std::string>::const_iterator it = tokens.begin();it != tokens.end(); it++){
            res=*it;
            if (first) {currenttime = atoi(res.c_str()); first=false;}
            else {currentcluster=atoi(res.c_str());break;}
        }
        times.clear();
        times.push_back(currenttime);
        timebyclusters.push_back(times);
        nbtimes++;
    }


    // Get list of objects per cluster

    ifstream fileObjects(data.c_str(), ios::in);


    if(!fileObjects)  {
        cerr << "Unable to open" << data << endl;
        exit(-1);
    }

    vector<vector <int> > objectbyclusters;
    map<int, vector<int> > amap;
    vector<int> intvector;
    map<int, vector<int> >::iterator ite;
    vector <int> objects;
    int currentobject;
    int nblignes=0;
    while(getline(fileObjects, ligne))
    {
        std::vector<std::string> tokens = split(ligne, delim);
        for (std::vector<std::string>::const_iterator it = tokens.begin();it != tokens.end(); it++){
            res=*it;
            currentobject = atoi(res.c_str());
            intvector.push_back(nblignes);
            amap[currentobject].push_back(nblignes);
        }
        nblignes++;
    }

    int j=0;



    // Extracting itemsets


   ifstream fileItemset(filename.c_str(), ios::in);
    if(!fileItemset)  {
        cerr << "Unable to open" << filename << endl;
        exit(-1);
    }
    vector <int> objectsitemsets;
    vector <int> timeitemsets;
    map<int, vector<int> > MymapObject;
    map<int, vector<int> > MymapTimes;
    map<int, vector<int> >::iterator Myite;
    int nb=0;

    while(getline(fileItemset, ligne))
    {
        std::size_t found = ligne.find(itemset);
        if (found!=std::string::npos){
            items.clear();
            string name = ligne;
            name.erase(0,itemset.length()+1);
            cluster= name;
            std::istringstream buf(cluster);
            for(std::string token; getline(buf, token, ' '); ){
                items.push_back(atoi(token.c_str()));
            }
            Itemsets.push_back(items);
            // get objects
            getline(fileItemset, ligne);
            std::vector<std::string> tokens = split(ligne, delim);
            first = true;
            for (std::vector<std::string>::const_iterator it = tokens.begin();it != tokens.end(); it++){
                res=*it;
                if (first) {
                    // find object
                    first=false;
                }
                else {
                    currentcluster=atoi(res.c_str());
                    MymapObject[nb].push_back(currentcluster);
                    objectsitemsets.push_back(currentcluster);
                }
            }


            // get time
            getline(fileItemset, ligne);
            tokens = split(ligne, delim);
            first = true;
            for (std::vector<std::string>::const_iterator it = tokens.begin();it != tokens.end(); it++){
                res=*it;
                if (first) {
                    // find Time
                    first=false;
                }
                else {
                    currentcluster=atoi(res.c_str());
                    MymapTimes[nb].push_back(currentcluster);
                    timeitemsets.push_back(currentcluster);
                }
            }
            nb++;
        }// found itemset
    }

    fileItemset.close();



    map<int, vector<int> > ListofInclusion;

    bool Result1;
    for (int i=0; i < (int)Itemsets.size(); i++){
            for (int j=0; j < (int)Itemsets.size(); j++){
                if (i!=j){
                    Result1 = includes(Itemsets[j].begin(), Itemsets[j].end(), Itemsets[i].begin(), Itemsets[i].end());
                    if(Result1){
                        ListofInclusion[j].push_back(i);
                        removeitemsets.push_back(patch::to_string(i));
                    }
                }

            }

    }



    //deletion of objects in MyMapObjects for itemsets
    map<int, vector<int> > MytempoObject=MymapObject;
    map<int, vector <int> >::iterator itera;
    for(Myite = ListofInclusion.begin(); Myite != ListofInclusion.end(); Myite++)
    {
        ite = MytempoObject.find(Myite->first);
        vector<int>MyObjects  = ite->second;
        vector<int> intvec = Myite->second;
        for(int j = 0; j < (int)intvec.size(); j++)
        {
            map<int, vector<int> >::iterator iter;
            map<int, vector<int> >::iterator it;
            vector <int> toto;

            it=MytempoObject.find(Myite->first);
            vector<int>MyObjects  = it->second;
            for (int k=0; k < (int)MyObjects.size(); k++){
                itera=MytempoObject.find(intvec[j]);
                toto= itera->second;
                for(vector <int>::iterator it_l = itera->second.begin(); it_l != itera->second.end(); ++it_l){
                    if (*it_l== MyObjects[k] ) {
                        itera->second.erase(it_l);
                        break;
                    }
                }
            }
        }


    }
       ite = MymapObject.find(Myite->first);



/*  REMOVE COMMENTS FOR CHECKING LIST OF ITEMSETS
    cout << "To check the itemsets " << endl;
    for (int i=0; i < (int)Itemsets.size(); i++){
        cout << "itemset: " << i << " : ";
        for (int j=0; j < (int)Itemsets[i].size(); j++)
            cout << Itemsets[i][j] << " ";
        cout << endl;
        cout << " - " << "objects: " << " ";
        ite=MymapObject.find(i);

        vector<int> intvec = ite->second;
        for(int j = 0; j < (int)intvec.size(); j++)
        {
            cout << intvec[j] << ", ";
        }
        cout << endl;

        cout << " - " << "times: " << " ";

        Myite=MymapTimes.find(i);
        intvec = Myite->second;
        for(int j = 0; j < (int)intvec.size(); j++)
        {
            cout << intvec[j] << ", ";
        }
        cout << endl;
    }

        cout << "pour verifier les objets restants " << endl;
    j=0;
    for(ite = MytempoObject.begin(); ite != MytempoObject.end(); ite++)
    {
        cout << "objets du cluster " << j++ << ": ";
        vector<int> intvec = ite->second;
        for(int i = 0; i < (int)intvec.size(); i++)
        {
            cout << intvec[i] << ", ";
        }
        cout << endl;
    }

 */

    /**********************************/
    /* Extraction of all the patterns */
    /**********************************/

    // Extracting trajectory GP
    ifstream filePathes(filename.c_str(), ios::in);
    if(!filePathes)  {
        cerr << "Unable to open" << filename << endl;
        exit(-1);
    }
    // GPatterns
    vector <int> objectsGP;
    vector <int> timeGP;
    map<int, vector<int> > MymapGPObject;
    map<int, vector<int> > MymapGPTimes;
    int nbGP=0;
    string newGP="GP";

    // Convoys
    vector <int> objectsCV;
    vector <int> timeCV;
    map<int, vector<int> > MymapCVObject;
    map<int, vector<int> > MymapCVTimes;
    int nbCV=0;
    string newCV="CV";


    // Fuzzy Closed Swarm
    vector <int> objectsfCS;
    vector <int> timefCS;
    map<int, vector<int> > MymapfCSObject;
    map<int, vector<int> > MymapfCSTimes;
    int nbfCS=0;
    string newfCS="fClSw";

    // Closed Swarm
    vector <int> objectsCS;
    vector <int> timeCS;
    map<int, vector<int> > MymapCSObject;
    map<int, vector<int> > MymapCSTimes;
    int nbCS=0;
    string newCS="CS";

    // RGPattern
    // Convergent
    vector <int> objectsConverge;
    vector <int> timeConverge;
    map<int, vector<int> > MymapConvergeObject;
    map<int, vector<int> > MymapConvergeTimes;
    int nbConverge=0;
    string newConverge="convergent";

    // Divergent
    vector <int> objectsDiverge;
    vector <int> timeDiverge;
    map<int, vector<int> > MymapDivergeObject;
    map<int, vector<int> > MymapDivergeTimes;
    int nbDiverge=0;
    string newDiverge="divergent";


    string summary="Summary:";

    while(getline(filePathes, ligne)) {
        std::size_t found;
        found=ligne.find(summary);
        if (found!=std::string::npos) break; // we are at the end of the file
        found= ligne.find(newGP);
        if (found!=std::string::npos) {
            ProcessPatterns(filePathes, objectsGP, timeGP, MymapGPObject, MymapGPTimes, nbGP);
        }
        found= ligne.find(newCV);
        if (found!=std::string::npos) {
            ProcessPatterns(filePathes, objectsCV, timeCV, MymapCVObject, MymapCVTimes, nbCV);
        }
        found= ligne.find(newCS);
        if (found!=std::string::npos) {
            ProcessPatterns(filePathes, objectsCS, timeCS, MymapCSObject, MymapCSTimes, nbCS);
        }
        found= ligne.find(newfCS);
        if (found!=std::string::npos) {
            ProcessPatterns(filePathes, objectsfCS, timefCS, MymapfCSObject, MymapfCSTimes, nbfCS);
        }
        found= ligne.find(newConverge);
        if (found!=std::string::npos) {
            ProcessPatterns(filePathes, objectsConverge, timeConverge, MymapConvergeObject, MymapConvergeTimes, nbConverge);
        }
        found= ligne.find(newDiverge);
        if (found!=std::string::npos) {
            ProcessPatterns(filePathes, objectsDiverge, timeDiverge, MymapDivergeObject, MymapDivergeTimes, nbDiverge);
        }
    }
    filePathes.close();


    /*  REMOVE COMMENTS FOR CHECKING LIST OF OBJECTS AND TIMES FOR ALL PATTERNS

    // TO print the objects of all the patterns

    cout << "_______ BEGIN OF GP _____" << endl;
    cout << "GP: " << endl;
    printPatterns(MymapGPObject,MymapGPTimes,nbGP);
    cout << "______ END OF GP ________" << endl;

    cout << "_______ BEGIN OF CV _____" << endl;
    cout << "CV: " << endl;
    printPatterns(MymapCVObject,MymapCVTimes,nbCV);
    cout << "______ END OF CV ________" << endl;

    cout << "_______ BEGIN OF CS _____" << endl;
    cout << "CV: " << endl;
    printPatterns(MymapCSObject,MymapCSTimes,nbCS);
    cout << "______ END OF CS ________" << endl;

    cout << "_______ BEGIN OF fCS ____" << endl;
    cout << "CV: " << endl;
    printPatterns(MymapfCSObject,MymapfCSTimes,nbfCS);
    cout << "______ END OF CfS _______" << endl;

    cout << "_ BEGIN OF Convergent __" << endl;
    cout << "CV: " << endl;
    printPatterns(MymapConvergeObject,MymapConvergeTimes,nbConverge);
    cout << "___ END OF Convergent __" << endl;

    cout << "_ BEGIN OF Divergent ___" << endl;
    cout << "CV: " << endl;
    printPatterns(MymapDivergeObject,MymapDivergeTimes,nbDiverge);
    cout << "___ END OF Divergent ___" << endl;

     */


    /* Extracting the principle objetcs from all the patterns
       meaning remove the inclusion for each pattern */

    vector <string> removeGP;

    map<int, vector<int> > ListofInclusionGP;

    //Result1;
    for (int i=0; i < (int)nbGP; i++){
        for (int j=0; j < (int)Itemsets.size(); j++){
            if (i!=j){
                Result1 = includes(Itemsets[j].begin(), Itemsets[j].end(), Itemsets[i].begin(), Itemsets[i].end());
                if(Result1){
                    ListofInclusion[j].push_back(i);
                    removeitemsets.push_back(patch::to_string(i));
                }
            }

        }

    }



 // Generating the Json file

    cout << "Generating the following json file to " << outputfile << " ..." << endl;
    ofstream fichier(outputfile.c_str(), ios::out | ios::trunc);
    if(!fichier)  {
        cerr << "Unable to open:" << outputfile << endl;
        exit(-1);
    }

    cout <<   "{" << endl;
    fichier <<   "{" << endl;
    // generation of links from itemsets
    cout <<    "\"links\": [" << endl;
    fichier <<    "\"links\": [" << endl;

    string buf;
    for (int i=0; i < (int)Itemsets.size(); i++){
        for (int j=0; j < (int)Itemsets[i].size()-1; j++){
            cout << "\t{\"source\":\"" ;
            fichier << "\t{\"source\":\"" ;
            for(ite = MytempoObject.begin(); ite != MytempoObject.end(); ite++){
                if (ite->first == i) {
                    buf="";
                    vector<int> intvec = ite->second;
                    buf+="\",\"value\":\""+patch::to_string(intvec.size())+"\",\"label\":\"";
                    for(int i = 0; i < (int)intvec.size(); i++){
                        buf+= patch::to_string(intvec[i]) + ",";
                    }
                if (buf[buf.length()-1]!='\"')
                    buf=buf.substr (0,buf.length()-1);
                break;
                }
            }
            if (i==(int)Itemsets.size()-1 && j == (int)Itemsets[i].size()-2){
                cout << Itemsets[i][j] << "\",\"target\":\"" << Itemsets[i][j+1] << buf << "\"}" << endl;
                fichier << Itemsets[i][j] << "\",\"target\":\"" << Itemsets[i][j+1] << buf << "\"}" << endl;
            }
            else if (j != (int)Itemsets[i].size()) {
                cout << Itemsets[i][j] << "\",\"target\":\"" << Itemsets[i][j+1] << buf << "\"}," << endl;
                fichier << Itemsets[i][j] << "\",\"target\":\"" << Itemsets[i][j+1] << buf << "\"}," << endl;
            }
        }
    }
    cout <<    "\t]," << endl;
    fichier <<    "\t]," << endl;

    // generation of patterns



    cout <<    "\"Gpatterns\": [" << endl;
    fichier <<    "\"Gpatterns\": [" << endl;
    generateJsonPatterns(fichier,MymapGPObject,MymapGPTimes,nbGP);
    cout << "\t]," << endl;
    fichier << "\t]," << endl;

    cout <<    "\"Convoys\": [" << endl;
    fichier <<    "\"Convoys\": [" << endl;
    generateJsonPatterns(fichier,MymapCVObject, MymapCVTimes, nbCV);
    cout << "\t]," << endl;
    fichier << "\t]," << endl;

    cout <<    "\"ClosedSwarms\": [" << endl;
    fichier <<    "\"ClosedSwarms\": [" << endl;
    generateJsonPatterns(fichier,MymapCSObject, MymapCSTimes, nbCS);
    cout << "\t]," << endl;
    fichier << "\t]," << endl;

    cout <<    "\"FuzzyClosedSwarms\": [" << endl;
    fichier <<    "\"FuzzyClosedSwarms\": [" << endl;
    generateJsonPatterns(fichier,MymapfCSObject, MymapfCSTimes, nbfCS);
    cout << "\t]," << endl;
    fichier << "\t]," << endl;


    cout <<    "\"Convergents\": [" << endl;
    fichier <<    "\"Convergents\": [" << endl;
    generateJsonPatterns(fichier,MymapConvergeObject, MymapConvergeTimes, nbConverge);
    cout << "\t]," << endl;
    fichier << "\t]," << endl;

    cout <<    "\"Divergents\": [" << endl;
    fichier <<    "\"Divergents\": [" << endl;
    generateJsonPatterns(fichier,MymapDivergeObject, MymapDivergeTimes, nbDiverge);
    cout << "\t]," << endl;
    fichier << "\t]," << endl;




    // generation of nodes
    cout << "\"nodes\": [" << endl;
    fichier << "\"nodes\": [" << endl;

    j=0;
    for(ite = amap.begin(); ite != amap.end(); ite++)
    {
        cout << "\t{\"name\":\"" << ite->first << "\",\"label\":\"" ;
        fichier << "\t{\"name\":\"" << ite->first << "\",\"label\":\"" ;

        vector<int> intvec = ite->second;
        std::string chaine="";
        for(int i = 0; i < (int)intvec.size(); i++)
        {
            chaine+=patch::to_string(intvec[i])+",";
        }
        cout << chaine.substr (0,chaine.length()-1);
        fichier << chaine.substr (0,chaine.length()-1);
        cout << "\",\"time\":\"" ;
        fichier << "\",\"time\":\"" ;
        chaine="";
        for (int j=0; j < (int)timebyclusters[ite->first].size();j++){
            chaine+=patch::to_string(timebyclusters[ite->first][j])+",";
        }
        cout << chaine.substr (0,chaine.length()-1);
        fichier << chaine.substr (0,chaine.length()-1);
        if (j != (int)amap.size()-1 ){
        cout << "\"}," << endl;
        fichier << "\"}," << endl;
        }
        else {
            cout << "\"}" << endl;
            fichier << "\"}" << endl;
        }
        j++;
    }
    cout << "\t]" << endl << "}" << endl;
    fichier << "\t]" << endl << "}" << endl;
    cout << endl << endl;
    cout << "\t\tThe json file generated is: " << outputfile  << endl << endl;
    return 0;
}
